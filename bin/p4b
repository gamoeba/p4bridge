#!/bin/bash

function listp4changes()
{
    git log --simplify-by-decoration --decorate --pretty=oneline p4_master | fgrep 'tag: ' | perl -ne '/tag: perforce#(\d+)/ && print "$1\n";' | sort -n -r
}

function lastp4change()
{
    listp4changes | head -n 1
}

function firstp4change()
{
    listp4changes | tail -n 1
}

function limitp4change()
{
    RET=$1
    FIRSTCHANGE=`firstp4change`
    LASTCHANGE=`lastp4change`
    if [[ $1 -gt $LASTP4CHANGE ]]
    then
        RET=$LASTCHANGE
    fi
    if [[ $1 -lt $FIRSTCHANGE ]]
    then
        RET=$FIRSTCHANGE
    fi
    echo $RET
}

function changedate()
{
    p4 change -o $1 | grep ^Date: | sed 's/^Date://' | tr -d '\011'
}

function changedesc()
{
    p4 change -o $1 -L | sed -e '1,/^Description/d' | tr -d '\011'
}

function changecommitter()
{
    p4 change -o $1 | grep ^User: | sed 's/^User://' | tr -d '\011'
}

function useremail()
{
    p4 user -o $1 | grep ^Email: | sed 's/^Email://' | tr -d '\011'
}

function userfullname()
{
    p4 user -o $1 | grep ^FullName: | sed 's/^FullName://' | tr -d '\011'
}

function amendChangelistWithCommitInfo()
{
AUTHOR=`changecommitter $1`
USERNAME=`userfullname $AUTHOR`
USEREMAIL=`useremail $AUTHOR`
AUTHORFMT="$USERNAME < $USEREMAIL >"

DATE=`changedate $1`
DESC="`changedesc $1`
perforce#$1"
if [ ! -z "$2" ]; then
    DESC="$DESC
$2"
fi
git commit --amend -q -m "$DESC" --author="$AUTHORFMT" --date="$DATE $P4BRIDGE_SERVERTIMEZONE"
}

function setlastp4change()
{
    git tag -af "perforce#$1" -m "p4bridge"
}

function upsearch () {
    test / == "$PWD" && return || test -e "$1" && return || cd .. && upsearch "$1"
}


read_properties()
{
  file="$1"
  while IFS="=" read -r key value; do
    case "$key" in
      '#'*) ;;
      *)
        eval "export $key=\"$value\""
    esac
  done < "$file"
}

# Runs before setdepot is available, so must define own variables
# also runs in parent directory initially, creates new directory,
# and then changes back to parent
function p4b_clone()
{
    if [ $# -eq 0 ]
    then
        echo "Usage: p4b clone //Depot/repo [starting changelist]"
        exit 1
    fi

    CHANGESPEC=""
    if [ -z "$2" ]
    then
        CHANGESPEC="@$2"
    fi

    P4BRIDGEDIR=".p4bridge"

    P4CLIENTPREFIX=$USER"_"`hostname -s`
    P4DEPOT=$1
    CLONEDIR=`echo $P4DEPOT | sed -E "s|(/\|//)|_|g" | sed -E "s/^_//g"`
    if [ -d "$CLONEDIR" ]
    then
        echo "Clone directory already exists"
        exit 1
    fi
    mkdir $CLONEDIR
    cd $CLONEDIR

    export P4CLIENT=$P4CLIENTPREFIX`echo $P4DEPOT | sed -E "s|(/\|//)|_|g"`
    mkdir -p $P4BRIDGEDIR
    echo "P4CLIENT=$P4CLIENT" > $P4BRIDGEDIR/config
    echo "P4DEPOT=$P4DEPOT" >> $P4BRIDGEDIR/config
    ROOT=`pwd`/$P4BRIDGEDIR/root
    mkdir -p $ROOT
    P4DEPOTTRIM=`echo $P4DEPOT | sed "s|//||g"`
    echo -e "Client: $P4CLIENT\nRoot: $ROOT\nOwner: $USER\nOptions: allwrite clobber compress\nView:\n\t$P4DEPOT/... //$P4CLIENT/...\n" | p4 client -i
    p4 sync -f $P4DEPOT/...$CHANGESPEC >/dev/null
    git init .
    echo $P4BRIDGEDIR/ >> .git/info/exclude
    git checkout -b p4_master
    p4b_availchanges $2 | while read CHG; do p4b_getupdate $CHG; done
    git checkout .
    git checkout -b master
    cd - > /dev/null
}


function setdepot()
{
    export P4BRIDGEDIR=".p4bridge"
    export P4BRIDGEROOTDIR=$P4BRIDGEDIR"/root"
    upsearch $P4BRIDGEDIR
    read_properties "$P4BRIDGEDIR/config"
}

function p4b_availchanges()
{
    p4 changes -s submitted $P4DEPOT/... | awk -v changelist=$1 '{ if ($2 > changelist) print $2 }' | sort -n
}


function p4b_getupdate()
{
    echo "fetching changelist $P4DEPOT@$1"
    p4 sync $P4DEPOT"/..."@$1 > /dev/null
    git --work-tree .p4bridge/root/ add --all
    git --work-tree .p4bridge/root/ commit -q -m "tmp"
    if [ $? -eq 0 ]
    then
        amendChangelistWithCommitInfo $1
        setlastp4change $1
    else
        echo "no changes, changelist skipped"
    fi
}

function p4b_preparechangelist()
{

    p4 sync -f $P4DEPOT/...@`lastp4change` > /dev/null
    CURR_BRANCH=`git rev-parse --abbrev-ref HEAD`

    git diff-tree --no-commit-id -r -M p4_master $CURR_BRANCH | awk -v dd=$P4BRIDGEROOTDIR '$5 ~ /^A/ {print "p4 add "dd"/"$6}; $5 ~ /^M/ {print "p4 edit "dd"/"$6}; $5 ~ /^R.*/ {print "p4 edit "dd"/"$6 "; p4 move "dd"/"$6" "dd"/"$7 } ' |
    while read -r line
    do
        eval $line
    done
    git --work-tree $P4BRIDGEROOTDIR checkout .
}

function p4b_revertchangelist()
{
    git diff-tree --no-commit-id -r $1 | awk -v dd=$DEPOTDIR '{print "p4 revert -w "dd"/"$6 }' |
    while read -r line
    do
        ${line}
    done
}

function p4b_shelve()
{

    if [ $# -eq 0 ]
    then
        echo "Usage: p4b shelve \"changelist description\""
        exit 1
    fi

    FILES=`p4 opened 2>/dev/null | sed -e 's/#.*//g' | while read FILE; do printf "\\t%s\\n" $FILE; done`
    echo -e "Change: new\nDescription: $1\nFiles:\n$FILES" | p4 shelve -i | grep "shelved" 
    p4 revert $FILES > /dev/null
}

function p4b_unshelve()
{
    # Check for proper number of command line args.

    EXPECTED_ARGS=1
    E_BADARGS=65

    if [ $# -ne $EXPECTED_ARGS ]
    then
        echo "Usage: `basename $0` {changelist-num}"
        exit $E_BADARGS
    fi

    CHANGELIST=$1
    export CURR_BRANCH=`git rev-parse --abbrev-ref HEAD`

    #remove any previous branch
    git branch -D shelved/$CHANGELIST 2>/dev/null
    #create a new orphaned branch
    git checkout --orphan shelved/$CHANGELIST
    #we don't want any content initially
    git reset --hard

    CHANGES=`p4 describe -s -S $CHANGELIST | sed -e '1,/^Shelved files.*/d' | awk '/^\s*$/{next;}{print $2}' `
    echo "$CHANGES" |
    while read CHG
    do
        if [[ ! "$CHG" =~ "#none" ]]
        then
            BASECL=`p4 fstat -T headChange $CHG | awk '/^\s*$/{next;}{print $3}'`
            FILENAME=`echo $CHG | sed -n -e 's|'"$P4DEPOT"'/\(.*\)#.*|\1|p' `
            BASECL=`limitp4change $BASECL`
            TAGNAME="perforce#$BASECL"
            git checkout $TAGNAME $FILENAME
        fi
    done
    git commit -q -m "Base file versions:
    $CHANGES"
    echo "$CHANGES" |
    while read CHG
    do
        P4FILENAME=`echo $CHG | sed -e 's|#.*||g'`
        MATCHSTR='s|'$P4DEPOT'/\(.*\)#.*|\1|p'
        FILENAME=`echo $CHG | sed -n -e $MATCHSTR `
        p4 unshelve -f -s $CHANGELIST $P4FILENAME > /dev/null
        git --work-tree $P4BRIDGEROOTDIR add $FILENAME
        # now reset both perforce and git indexes
        p4 revert $P4FILENAME > /dev/null
        git checkout $FILENAME
    done

    git --work-tree $P4BRIDGEROOTDIR commit -q -m "tmp"
    amendChangelistWithCommitInfo $CHANGELIST "Shelved@$1
    Previous versions of files:
    $CHANGES"

    git tag -af "shelved#$CHANGELIST" -m "p4bridge"

    git checkout $CURR_BRANCH
}

function p4b_update()
{

    OPENED=`p4 opened 2>/dev/null | wc -l`
    if [ ! $OPENED -eq 0 ]
    then
        echo "open files in perforce, please revert or shelve first"
        exit 1
    fi
    CURR_BRANCH=`git rev-parse --abbrev-ref HEAD`
    git checkout p4_master && p4b_availchanges `lastp4change` | while read CHG; do p4b_getupdate $CHG; done
    git checkout .
    git checkout $CURR_BRANCH
}

E_BADARGS=65

if [[ $# -lt 1 ]]
then
 echo "Usage: `basename $0` command {command-args}"
 exit $E_BADARGS
fi	
command=$1
shift
if [ ! "$command" = "clone" ]
then
    setdepot
fi
p4b_$command "$@"
